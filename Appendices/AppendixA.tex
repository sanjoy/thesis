% Appendix A

\chapter{Parameterizing \texttt{wattage}} % Main appendix title

\label{AppendixA}

\lhead{Appendix A. Parameterizing \texttt{wattage}}

\texttt{wattage} is parameterized on a number of values called
\textit{traits}.  These describe the processor's power usage
characteristics and thus can be tweaked to retarget \texttt{wattage}
to any reasonable microarchitecture.  The complete list of parameters
can be obtained by invoking \texttt{wattage} with the command line
argument \texttt{-print\_trait\_names}.

\begin{minted}[linenos, frame=lines]{bash}
  ./pin/pin -t wattage.so -print_trait_names -- ls
\end{minted}

\section{Classification of parameters}

The above command spits out forty-five traits.  Instead of describing
them individually, a more systematic methodology would be to partition
them into two separate forms:

\subsection{Traits of the form \texttt{category\_*\_weight}}

The \texttt{category\_*\_weight} traits describe the base instruction
costs for instructions belonging to a certain category -- for instance
\texttt{category\_float\_division\_weight} is the base instruction
cost for instructions that perform floating point divisions.  When
computing base instruction costs, we choose towards the most specific
category an instruction belongs to, so an integer division instruction
will incur \texttt{category\_integer\_division\_weight} as its base
instruction cost while an arithmetic integer operation that doesn't
fall into any specific category will be taken to consume
\texttt{category\_generic\_alu\_weight}.

\subsection{Traits of the form \texttt{quantity\_subsystem\_wt\_(individual | hamming) \allowbreak [\_(read | write)]}}

The names rest of the traits follow the form
\texttt{quantity\_subsystem\_wt\_(individual | hamming) \allowbreak
  [\_(read | write)]}.  We describe the elements that make up the
above form using \texttt{data\_value\_mem\_wt\_individual\_write} as
an example.

\begin{description}
\item[\texttt{\hlight{data\_value}\_mem\_wt\_individual\_write}] \hfill

  \texttt{data\_value} is the \textit{quantity} this weight will act
  on.  The possible values for this are

  \begin{description*}
  \item[\texttt{imm\_operand}]\hfill \\ The immediate operands
    embedded in the current instruction.  So for \texttt{movq \$1024,
      \%rax}, the value of this quantity is \texttt{42}.
    
  \item[\texttt{reg}] \hfill \\ The code for any registers accessed in
    the current instruction.  For \texttt{movq \$1024, \%rsi}, this
    will be \texttt{6}, the encoding for \texttt{\%rsi}.
    
  \item[\texttt{reg\_value}] \hfill \\ The value of the register file.
    Wattage interprets this as the cumulative value of all the general
    purpose registers.

  \item[\texttt{inst\_addr}] \hfill \\ The instruction address.

  \item[\texttt{data\_addr}] \hfill \\ The address of the data
    accessed in the current instruction, if any.

  \item[\texttt{inst\_value}] \hfill \\ The value of the current
    instruction (interpreted as a binary blob of data).

  \item[\texttt{data\_value}] \hfill \\ The value of the data fetched
    in the current instruction, if any.

  \end{description*}

\item[\texttt{data\_value\hlight{\_mem\_wt}\_individual\_write}] \hfill

  \texttt{mem\_wt} tell us that this weight affects the quantity's
  contribution to the energy estimate for the \textit{memory
    subsystem}.  The alternative for this is \texttt{cpu\_wt}, such
  weights affect the contribution to the energy estimate for the
  \textit{CPU subsystem}.

\item[\texttt{data\_value\_mem\_wt\_\hlight{individual}\_write}] \hfill

  \texttt{individual} tells us that this weight is multiplied with the
  \textit{number of ones} in the current value of quantity (so if the
  value of the quantity is \texttt{42}, this weight will be multiplied
  with \texttt{3}).  The alternative to this is \texttt{hamming} which
  tells that the weight is multiplied with the number of bits
  \textit{changed} from the last value of the quantity (so, for
  instance, when the value changes from \texttt{42} to \text{50} the
  weight is multiplied with \text{2}).

\item[\texttt{data\_value\_mem\_wt\_individual\_\hlight{write}}] \hfill

  This optional part of the trait name tells us that the weight will
  be considered when the quantity is being \textit{written} to the
  memory.  The alternative is \texttt{read} with the obvious meaning.
  
\end{description}

\subsection{Other traits}

Saving the traits mentione above, \texttt{wattage} parameterizes on
two other parameters, \texttt{base\_mem\_value\_wt} and
\texttt{base\_mem\_word\_width\_wt}.  These are used to approximate
the $BaseMem$ parameter mentioned in \cite{steinke}.  $BaseMem(buffer,
bufferSize)$ is calculated as $ValueScale \times HammingWeight(buffer)
+ WidthScale \times bufferSize$ where $ValueScale$ is
\texttt{base\_mem\_value\_wt} and $WidthScale$ is
\texttt{base\_mem\_word\_width\_wt}.

\section{Parameters for the x86}

Parameters for the x86 ISA were derived from values mentioned in
\cite{steinke} and \cite{lee}.  The inferences mentioned in this work
should be largely resistant to reasonable modification to the CPU
traits assumed.

\begin{longtable}{l|l}
  \caption{Estimated CPU Traits for the x86 ISA} \\

  \hline \\

  \texttt{imm\_operand\_cpu\_wt\_individual} & 1 \\
  \texttt{imm\_operand\_cpu\_wt\_hamming} & 2 \\

  \texttt{reg\_cpu\_wt\_individual} & 8.13 \\
  \texttt{reg\_cpu\_wt\_hamming} & 4.73 \\

  \texttt{reg\_value\_cpu\_wt\_individual} & 1 \\
  \texttt{reg\_value\_cpu\_wt\_hamming} & 2 \\

  \texttt{inst\_addr\_cpu\_wt\_individual} & 48 \\
  \texttt{inst\_addr\_cpu\_wt\_hamming} & 219.9 \\

  \texttt{data\_addr\_cpu\_wt\_individual} & 48 \\
  \texttt{data\_addr\_cpu\_wt\_hamming} & 219.9 \\

  \texttt{inst\_addr\_mem\_wt\_individual} & -19.2 \\
  \texttt{inst\_addr\_mem\_wt\_hamming} & 138.9 \\

  \texttt{inst\_value\_mem\_wt\_individual} & -115.3 \\
  \texttt{inst\_value\_mem\_wt\_hamming} & 57.7 \\

  \texttt{data\_addr\_mem\_wt\_individual} & -19.2 \\
  \texttt{data\_addr\_mem\_wt\_hamming} & 138.9 \\

  \texttt{data\_value\_cpu\_wt\_individual\_read} & 0 \\
  \texttt{data\_value\_cpu\_wt\_individual\_write} & 0 \\

  \texttt{data\_value\_cpu\_wt\_hamming\_read} & 0 \\
  \texttt{data\_value\_cpu\_wt\_hamming\_write} & 0 \\

  \texttt{data\_value\_mem\_wt\_individual\_read} & -115.3 \\
  \texttt{data\_value\_mem\_wt\_individual\_write} & -60.4 \\

  \texttt{data\_value\_mem\_wt\_hamming\_read} & 57.7 \\
  \texttt{data\_value\_mem\_wt\_hamming\_write} & 22.8 \\

  \texttt{category\_default\_weight} & 1000 \\
  \texttt{category\_generic\_alu\_weight} & 896.87 \\
  \texttt{category\_integer\_multiplication\_weight} & 900 \\
  \texttt{category\_integer\_division\_weight} & 900 \\
  \texttt{category\_float\_division\_weight} & 900 \\
  \texttt{category\_unary\_arithmetic\_operation\_weight} & 800 \\
  \texttt{category\_binary\_arithmetic\_operation\_weight} & 900 \\
  \texttt{category\_shift\_rotate\_weight} & 100 \\
  \texttt{category\_double\_shift\_weight} & 100 \\
  \texttt{category\_conditional\_move\_weight} & 500 \\
  \texttt{category\_set\_weight} & 500 \\
  \texttt{category\_jump\_weight} & 500 \\
  \texttt{category\_loop\_weight} & 500 \\
  \texttt{category\_call\_weight} & 1000 \\
  \texttt{category\_return\_weight} & 1000 \\
  \texttt{category\_sign\_extension\_weight} & 800 \\
  \texttt{category\_zero\_extension\_weight} & 800 \\
  \texttt{category\_sse\_weight} & 1200 \\
  \texttt{category\_mmx\_weight} & 1200 \\
  \texttt{category\_system\_weight} & 1100 \\
  \texttt{category\_nop\_weight} & 50 \\

  \texttt{base\_mem\_value\_wt} & 250 \\
  \texttt{base\_mem\_word\_width\_wt} & 100 \\

  \hline \\
\end{longtable}
